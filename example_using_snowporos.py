# -*- coding: utf-8 -*-
"""
Created on Thu Feb  1 16:07:18 2024

This file show an example for applying the snowporos algorithm on a 2D image

## License for snow_poros.py

Copyright © 2025 Technical University of Denmark

This project is licensed under the MIT License.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

import matplotlib.pyplot as plt
import numpy as np
import porespy as ps
import pypardiso
import snow_poros
from snow_poros import snow_porosimetry
import skimage
import scipy
from skimage .morphology import disk


# In[14]:


def weighted_avg_and_std(values, weights):
    """
    Return the weighted average and standard deviation.

    values, weights -- Numpy ndarrays with the same shape.
    """
    average = np.average(values, weights=weights)
    # Fast and numerically precise:
    variance = np.average((values-average)**2, weights=weights)
    return (average, np.sqrt(variance))



#np.random.seed(10)
size = 3.51 # micrometer/pixel. Size of each pixel

# Reading the file and transform it into a binary images (only 1 and 0)
img=skimage.io.imread("image3_.tiff")
img_binary=(img==2)


# Cropping the image (to avoid including the scale bar)
img_binary=img_binary[400:1000,300:900]
plt.imshow(img_binary,cmap="gray")

#Clean images
image_binary_filtered=skimage.morphology.remove_small_holes(img_binary)


# Padding the borders of the images. The border of the image are set to 0 value
im=np.pad(img_binary,pad_width=1, mode="constant",constant_values=0)



#Perform of the porosimetry method
lt_median=ps.filters.porosimetry(im,sizes=25,access_limited=False)
lt_median=2*size*lt_median # To record the diameter


plt.imshow(lt_median,extent=(0, size * len(im[0]), 0, size * len(im)))
fig=plt.colorbar(label="Pore diameter [μm]")
plt.show()

#%%
# Perform of the SNOW algorithm
snow_out=ps.filters.snow_partitioning(im,r_max=4,sigma=0.35)

        # Labelling the regions generated from the SNOW algorithm
snow_region_props=skimage.measure.regionprops(snow_out.regions)

                 # Calculation of the area of each region
snow_areas= np.array([prop.area for prop in snow_region_props])*(size*size)

                # Calculation of the equivalent diameter
snow_diameter= np.array([prop.equivalent_diameter for prop in snow_region_props])*size

                #Calculation of the aspect ratio
snow_majoraxis=np.array([prop.axis_major_length for prop in snow_region_props])*size
snow_minoraxis=np.array([prop.axis_minor_length for prop in snow_region_props])*size
snow_aspect=snow_minoraxis/snow_majoraxis

                # Creating the color map for the pore size distribution            
snow_diameter_map=snow_out.regions.copy()

for region in snow_region_props:
    for cords in region.coords:
        snow_diameter_map[cords[0],cords[1]]=region.equivalent_diameter*size

              # Print the map
plt.figure(figsize=(18,9))
plt.imshow (snow_diameter_map,extent=([0,size*len(im[0]),0,size*len(im)]))
plt.xlabel("x [μm]", fontsize=12)
plt.ylabel("y [μm]",fontsize=12)
fig=plt.colorbar(label="Pore diameter [μm]")
plt.show()

#%%
#Perform of the SNOWPOROS algorithm
snow_poros_out=snow_porosimetry(snow_out,lt_median,im)

      # Labelling the regions generated by the SNOWPOROS
snowporos_region_props_improved=skimage.measure.regionprops(snow_poros_out.regions)

              # Calculation of the area of each region
snowporos_areas_improved= np.array([prop.area for prop in snowporos_region_props_improved])*size

               # Calculation of the equivalent diameter of each region
snowporos_diameter_improved= np.array([prop.equivalent_diameter for prop in snowporos_region_props_improved])*size
         
                #Calculation of the aspect ratio
snowporos_majoraxis=np.array([prop.axis_major_length for prop in snowporos_region_props_improved])*size
snowporos_minoraxis=np.array([prop.axis_minor_length for prop in snowporos_region_props_improved])*size
snowporos_aspect=snowporos_minoraxis/snowporos_majoraxis
# Creating the color map for the pore size distribution  
snowporos_diameter_map=snow_poros_out.regions.copy()

for region in snowporos_region_props_improved:
    for cords in region.coords:
        snowporos_diameter_map[cords[0],cords[1]]=region.equivalent_diameter*size
#%matplotlib qt
        
# Print the map
plt.figure(figsize=(18,9))
plt.imshow (snowporos_diameter_map,extent=([0,size*len(im[0]),0,size*len(im)]))
plt.xlabel("x [μm]", fontsize=12)
plt.ylabel("y [μm]",fontsize=12)
fig=plt.colorbar(label="Pore diameter [μm]")
plt.show()


#%% Comparing pore sizes of the different methods
bins=np.linspace(0.1,np.max(snowporos_diameter_improved),num=30)
bin_center=(bins[1:]+bins[:-1])/2
bin_width=(bins[1]-bins[0])

porosimetry=lt_median
psd_porosimetry_norm = ps.metrics.pore_size_distribution(porosimetry, bins=bins, log=False).satn

# Discretization in bins of the SNOW Algorithm

psd_snow=scipy.stats.binned_statistic(snow_diameter.ravel(),snow_areas.ravel(),statistic="sum",bins=bins)
psd_snow_norm=np.nan_to_num(psd_snow.statistic)/np.nan_to_num(np.sum(psd_snow.statistic))

# Discretization in bins of the SNOWPOROS algorithm.
psd_snowporos_improved=scipy.stats.binned_statistic(snowporos_diameter_improved.ravel(),snowporos_areas_improved.ravel(),statistic="sum",bins=bins)
psd_snowporos_norm_improved=np.nan_to_num(psd_snowporos_improved.statistic)/np.nan_to_num(np.sum(psd_snowporos_improved.statistic))


# Visualization of the methods
hatch_pattern = '///'
plt.figure(figsize=(10,10))

plt.bar(bin_center,psd_porosimetry_norm,bin_width,facecolor="red", alpha=0.8)
plt.bar(bin_center,psd_snow_norm,bin_width,facecolor="green", alpha=0.5)
plt.bar(bin_center,psd_snowporos_norm_improved,bin_width,hatch=hatch_pattern,edgecolor="blue",color="None")

plt.xlabel("Equivalent pore diameter [μm]",fontsize=15)
plt.ylabel("Area fraction [-]",fontsize=15)
plt.legend(["PSD porosimetry","PSD SNOW","PSD snowporos"],fontsize=15,loc="upper right")
plt.title=("Equivalent pore diameter")